---
title: HAL Functions Reference
parent: STM32
nav_order: 2
layout: default
---


# HAL (Hardware Abstraction Layer) Functions Reference Guide

<details markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

This guide explains the Hardware Abstraction Layer (HAL) functions used in the Unit 3 LCD Test project. HAL functions provide easy access to the microcontroller's hardware without needing to know low-level register details. You'll find explanations of the most commonly used HAL functions, their syntax, parameters, and examples of how they work in your project.

You are not expected to memorise all these functions! Instead, this guide serves as a reference to understand what each function does and how it fits into your project. The key takeaway is that HAL functions allow you to control the hardware (GPIO, ADC, UART, etc.) in a simple and consistent way.

## What is HAL?

The **Hardware Abstraction Layer** is a library provided by STMicroelectronics that abstracts away the complexity of the STM32 microcontroller. Instead of writing direct register access code, you call simple functions like `HAL_GPIO_WritePin()`.

```
Your Code                HAL Library              Microcontroller Registers
┌──────────────────┐    ┌───────────────────┐    ┌──────────────────────┐
│ HAL_GPIO_Toggle  │───>│ Translation to    │───>│ GPIOA->BSRR = ...    │
│ HAL_Delay        │    │ register commands │    │ TIM2->CR1 |= TIM_... │
│ HAL_UART_Transmit│    │ (abstraction)     │    │ SPI2->DR = ...       │
└──────────────────┘    └───────────────────┘    └──────────────────────┘
```

---

## Initialization Functions

### HAL_Init()

**Purpose:** Initialize the HAL library. Must be called first in your program.

**Syntax:**
```c
void HAL_Init(void);
```

**What it does:**
- Sets up the Systick timer (for `HAL_GetTick()` and `HAL_Delay()`)
- Initializes priority grouping which handles interrupts
- Prepares the HAL for general use

**Example:**
```c
int main(void) {
    HAL_Init();  // Must be called first!
    
    SystemClock_Config();
    MX_GPIO_Init();
    // ... rest of initialization
}
```

**Important:** Call this before any other HAL functions.

---

### SystemClock_Config()

**Purpose:** Configure the system clock frequency for optimal performance.

**Syntax:**
```c
void SystemClock_Config(void);
```

**What it does:**
- Enables the PLL (Phase-Locked Loop) oscillator
- Sets the system clock to 80 MHz (the maximum for STM32L476)
- Configures the AHB and APB buses

**In your project:** The system runs at 80 MHz, which means:
- SPI2 (for LCD) gets 80 MHz
- UART2 (for serial) gets 80 MHz
- All timers and peripherals get the full clock speed

**You don't need to understand the details** - it's auto-generated by CubeMX and just needs to be called once at startup.

---

### MX_GPIO_Init()

**Purpose:** Initialize all GPIO pins as configured in CubeMX.

**Syntax:**
```c
void MX_GPIO_Init(void);
```

**What it does:**
- Configures each GPIO pin as input or output
- Sets pull-up/pull-down resistors
- Sets the speed and alternate functions
- Enables the GPIO port clocks

**In your project:** This sets up:
- LED pin (PA5) as output
- Button pin as input
- SPI pins for LCD communication

**Auto-generated:** CubeMX creates this function based on your `.ioc` file configuration.

---

### MX_USART2_UART_Init()

**Purpose:** Initialize UART2 (serial communication) for the serial console.

**Syntax:**
```c
void MX_USART2_UART_Init(void);
```

**What it does:**
- Configures UART2 with 115200 baud rate
- Sets up TX (transmit) and RX (receive) pins
- Enables the UART peripheral clock

**Result:** This enables `printf()` to work by redirecting serial output.

**Auto-generated:** CubeMX creates this based on your configuration.

---

## GPIO (General Purpose Input/Output) Functions

GPIO functions control digital input and output pins.

### HAL_GPIO_WritePin()

**Purpose:** Set a GPIO pin to HIGH (3.3V) or LOW (0V).

**Syntax:**
```c
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
```

**Parameters:**
- `GPIOx` - Which port (GPIOA, GPIOB, etc.)
- `GPIO_Pin` - Which pin (GPIO_PIN_0, GPIO_PIN_1, etc.)
- `PinState` - GPIO_PIN_SET (HIGH/3.3V) or GPIO_PIN_RESET (LOW/0V)

**Example: Turn on LED**
```c
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);  // LED on (3.3V)
HAL_Delay(500);  // Wait 500ms
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);  // LED off (0V)
```

---

### HAL_GPIO_ReadPin()

**Purpose:** Read the current state of a GPIO input pin.

**Syntax:**
```c
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
```

**Returns:**
- `GPIO_PIN_SET` if the pin is HIGH (3.3V)
- `GPIO_PIN_RESET` if the pin is LOW (0V)

**Example: Read button state**
```c
GPIO_PinState button_state = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);

if (button_state == GPIO_PIN_SET) {
    printf("Button is pressed\n");
} else {
    printf("Button is not pressed\n");
}
```
**In your project:** Used to read the status of the blue button (B1) during the Magic 8Ball lab.


---

### HAL_GPIO_TogglePin()

**Purpose:** Toggle a GPIO pin (switch it to the opposite state).

**Syntax:**
```c
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
```

**What it does:**
- If pin is HIGH, set it LOW
- If pin is LOW, set it HIGH

**Example: Blinking LED**
```c
while(1) {
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);  // Toggle LED
    HAL_Delay(500);  // Wait 500ms
}
// Result: LED blinks every 500ms
```

**In your project:** Used to flash the green LED (LD2) during the welcome message.

---

## Timing Functions

### HAL_Delay()

**Purpose:** Pause execution for a specified number of milliseconds.

**Syntax:**
```c
void HAL_Delay(uint32_t Delay);
```

**Parameters:**
- `Delay` - Number of milliseconds to wait (0-4,294,967,295)

**Example:**
```c
printf("Starting countdown...\n");
HAL_Delay(1000);  // Wait 1 second
printf("Go!\n");
```

**In your project:** Used extensively for delays between LCD refreshes and animations:
```c
LCD_Fill_Buffer(0);
LCD_printString("Welcome", 20, 10, 1, 5);
LCD_Refresh(&cfg0);
HAL_Delay(200);  // Wait 200ms before next text
```

**Performance note:** Blocking delay - the CPU does nothing else while waiting. For a 500ms delay, the CPU sits idle for 500ms.

---

### HAL_GetTick()

**Purpose:** Get the current system tick count (milliseconds since startup).

**Syntax:**
```c
uint32_t HAL_GetTick(void);
```

**Returns:** Number of milliseconds since `HAL_Init()` was called.

**Example: Measure elapsed time**
```c
uint32_t start_time = HAL_GetTick();

// Do some work...

uint32_t elapsed = HAL_GetTick() - start_time;
printf("Operation took %lu ms\n", elapsed);
```

**Use case: Game timing**
```c
uint32_t last_frame_time = 0;

while(1) {
    uint32_t current_time = HAL_GetTick();
    
    if (current_time - last_frame_time >= 50) {  // 50ms = 20 FPS
        // Update game frame
        last_frame_time = current_time;
    }
}
```

---

## UART (Serial Communication) Functions

### HAL_UART_Transmit()

**Purpose:** Send data over the serial port (UART).

**Syntax:**
```c
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, 
                                     uint16_t Size, uint32_t Timeout);
```

**Parameters:**
- `huart` - UART handle (in your case, `&huart2`)
- `pData` - Pointer to data to send
- `Size` - Number of bytes to send
- `Timeout` - Maximum time to wait (in ms, use `HAL_MAX_DELAY` for infinite)

**Example: Send a string**
```c
char message[] = "Hello World\r\n";
HAL_UART_Transmit(&huart2, (uint8_t*)message, sizeof(message)-1, HAL_MAX_DELAY);
```

**In your project:** Used indirectly by `printf()`. The `_write()` function (in main.c) redirects printf output to this function:

```c
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}
```

This is why `printf()` works and prints to the serial monitor!

**Blocking:** This function waits for transmission to complete before returning.

---

## ADC (Analog-to-Digital Converter) Functions

ADC functions allow you to read analog voltages from the joystick and convert them to digital values.

### HAL_ADC_Start()

**Purpose:** Start ADC conversion in polling mode (blocking).

**Syntax:**
```c
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef *hadc);
```

**Parameters:**
- `hadc` - ADC handle (in your case, `&hadc1`)

**Returns:** HAL_OK if successful, HAL_ERROR otherwise

**Example:**
```c
if (HAL_ADC_Start(&hadc1) != HAL_OK) {
    printf("ADC failed to start\n");
    while(1);  // Error
}
```

**In your project:** Used to start reading analog values from joystick pins (X and Y axes).

---

### HAL_ADC_PollForConversion()

**Purpose:** Wait for ADC conversion to complete (blocking call).

**Syntax:**
```c
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout);
```

**Parameters:**
- `hadc` - ADC handle
- `Timeout` - Maximum time to wait in milliseconds (use `HAL_MAX_DELAY` for infinite)

**Returns:** HAL_OK if conversion completed, HAL_TIMEOUT if timeout occurred

**Example: Read joystick X axis**
```c
HAL_ADC_Start(&hadc1);  // Start conversion

// Wait for conversion to finish
if (HAL_ADC_PollForConversion(&hadc1, 100) == HAL_OK) {
    uint32_t adc_value = HAL_ADC_GetValue(&hadc1);
    printf("X-axis: %lu\n", adc_value);
} else {
    printf("Conversion timeout\n");
}
```

**In your project:** Essential for reading joystick analog values in the main game loop.

---

### HAL_ADC_GetValue()

**Purpose:** Retrieve the last ADC conversion result.

**Syntax:**
```c
uint32_t HAL_ADC_GetValue(const ADC_HandleTypeDef *hadc);
```

**Returns:** The ADC conversion result (typically 0-4095 for 12-bit ADC)

**Example: Read and normalize joystick value**
```c
uint32_t raw_value = HAL_ADC_GetValue(&hadc1);

// Normalize to -1.0 to 1.0 range
float normalized = (raw_value - 2048.0f) / 2048.0f;
printf("Normalized X: %.2f\n", normalized);
```

**In your project:** Called after `HAL_ADC_PollForConversion()` to get the actual analog reading.

---

### HAL_ADC_Stop()

**Purpose:** Stop ADC conversion.

**Syntax:**
```c
HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef *hadc);
```

**Returns:** HAL_OK if successful

**Example:**
```c
HAL_ADC_Stop(&hadc1);  // Stop reading ADC
```

**In your project:** Called during shutdown or when you want to stop reading joystick input.

---

### MX_ADC1_Init()

**Purpose:** Initialize ADC1 peripheral with CubeMX settings.

**Syntax:**
```c
void MX_ADC1_Init(void);
```

**What it does:**
- Enables ADC1 clock
- Configures analog input pins for joystick
- Sets ADC resolution (12-bit)
- Configures sampling time and conversion rate

**Auto-generated:** CubeMX creates this function based on your `.ioc` configuration.

**In your project:** Called during initialization to set up the ADC for reading joystick X, Y, and button values.

---

## RNG (Random Number Generator) Functions

RNG functions provide hardware-based random number generation for better randomness than software-based `rand()`.

### HAL_RNG_Init()

**Purpose:** Initialize the RNG peripheral.

**Syntax:**
```c
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng);
```

**Parameters:**
- `hrng` - RNG handle (in your case, `&hrng`)

**Returns:** HAL_OK if successful

**Example:**
```c
if (HAL_RNG_Init(&hrng) != HAL_OK) {
    printf("RNG initialization failed\n");
    while(1);
}
```

**In your project:** Called during system initialization to enable hardware random number generation.

---

### HAL_RNG_GenerateRandomNumber()

**Purpose:** Generate a 32-bit random number using the hardware RNG.

**Syntax:**
```c
HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit);
```

**Parameters:**
- `hrng` - RNG handle
- `random32bit` - Pointer to store the generated random number

**Returns:** HAL_OK if successful

**Example: Generate random number in range [0, max]**
```c
uint32_t random_value;

if (HAL_RNG_GenerateRandomNumber(&hrng, &random_value) == HAL_OK) {
    uint16_t random_in_range = random_value % max;  // 0 to max-1
    printf("Random number: %u\n", random_in_range);
}
```

**In your project:** Used in the Joystick Game to randomly generate game events, AI behaviour, or puzzle elements.

**Advantage over `rand()`:** Hardware RNG provides better randomness and is less predictable than software pseudorandom number generators.

---

### MX_RNG_Init()

**Purpose:** Initialize RNG peripheral with CubeMX settings.

**Syntax:**
```c
void MX_RNG_Init(void);
```

**What it does:**
- Enables RNG clock
- Configures RNG for maximum randomness

**Auto-generated:** CubeMX creates this function.

**In your project:** Called during system initialization.

---

## Expanded System Clock Configuration

Beyond `SystemClock_Config()`, you may need to understand the underlying RCC functions for advanced configurations.

### HAL_RCC_OscConfig()

**Purpose:** Configure RCC oscillators (crystal oscillator or PLL).

**Syntax:**
```c
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
```

**What it does:**
- Configures HSI (Internal clock) or HSE (External crystal)
- Sets up PLL multiplier and divider
- Enables/disables oscillators

**Note:** This is typically called by the auto-generated `SystemClock_Config()` function and you won't need to call it directly.

---

### HAL_RCC_ClkConfig()

**Purpose:** Configure system clock distribution and prescalers.

**Syntax:**
```c
HAL_StatusTypeDef HAL_RCC_ClkConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);
```

**What it does:**
- Selects clock source (HSI, HSE, or PLL)
- Sets AHB prescaler (affects CPU speed)
- Sets APB1 and APB2 prescalers (affects peripheral speeds)

**Note:** Called by `SystemClock_Config()` to set your system to 80 MHz.

---

### HAL_RCCEx_PeriphCLKConfig()

**Purpose:** Configure peripheral-specific clock sources.

**Syntax:**
```c
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef *PeriphClkInit);
```

**What it does:**
- Configures ADC clock source and prescaler
- Configures RNG clock
- Configures UART/SPI clock sources

**In your project:** Used to set ADC and RNG clock frequencies.

---

### PeriphCommonClock_Config()

**Purpose:** Initialize common peripheral clocks (auto-generated by CubeMX).

**Syntax:**
```c
void PeriphCommonClock_Config(void);
```

**What it does:**
- Enables clocks for ADC, RNG, and other peripherals
- Calls `HAL_RCCEx_PeriphCLKConfig()` internally

**In your project:** Called during system initialization to set up clocks for ADC and RNG.

---

## Power Management Functions

### HAL_PWREx_ControlVoltageScaling()

**Purpose:** Control the internal voltage regulator output level.

**Syntax:**
```c
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
```

**Parameters:**
- `VoltageScaling` - Voltage level (PWR_REGULATOR_VOLTAGE_SCALE1 for 80 MHz operation)

**Returns:** HAL_OK if successful

**Example:**
```c
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK) {
    printf("Voltage scaling failed\n");
}
```

**In your project:** Called by `SystemClock_Config()` to set the correct voltage for 80 MHz operation. Higher clock speeds require higher voltage.

**Important:** Must be called before increasing the system clock frequency.

---

## Common HAL Status Values

Many HAL functions return a status to indicate success or failure:

```c
HAL_StatusTypeDef status = HAL_SPI_Transmit(&hspi2, data, length, timeout);

if (status == HAL_OK) {
    // Success!
} else if (status == HAL_ERROR) {
    // Error occurred
} else if (status == HAL_BUSY) {
    // Peripheral is busy
} else if (status == HAL_TIMEOUT) {
    // Timeout waiting for operation
}
```

---

## HAL in Your Project: Usage Summary

Here's how the HAL functions work together in your LCD test:

```c
int main(void) {
    // 1. Initialize HAL
    HAL_Init();
    
    // 2. Configure system clock for 80 MHz
    SystemClock_Config();
    
    // 3. Initialize GPIO pins
    MX_GPIO_Init();
    
    // 4. Initialize serial port
    MX_USART2_UART_Init();
    
    // 5. Now you can use HAL functions
    while(1) {
        // LED control
        HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
        
        // Timing
        HAL_Delay(500);
        
        // Serial output (via printf)
        printf("Elapsed: %lu ms\n", HAL_GetTick());
    }
}
```

---

## Important HAL Patterns

### 1. Always Initialize First

```c
// Wrong - HAL functions won't work yet
HAL_Delay(1000);
HAL_Init();

// Correct - Initialize before using
HAL_Init();
SystemClock_Config();
HAL_Delay(1000);  // Now this works
```

### 2. Use Handles for Peripherals

Most HAL functions take a "handle" - a structure containing peripheral configuration:

```c
// UART handle (created by CubeMX)
extern UART_HandleTypeDef huart2;

// Use the handle to access the peripheral
HAL_UART_Transmit(&huart2, data, length, timeout);
```

### 3. Check Return Values

For critical operations, check if they succeeded:

```c
HAL_StatusTypeDef status = HAL_UART_Transmit(&huart2, data, 100, 1000);

if (status != HAL_OK) {
    printf("Serial transmission failed!\n");
    while(1);  // Hang if critical error
}
```

---

## Related: The LCD Driver Functions

Note that the LCD functions (like `LCD_Fill_Buffer()` and `LCD_Refresh()`) are **not** HAL functions - they're part of the ST7789V2 driver library. However, they internally use HAL functions like:

```c
// Inside LCD driver
void LCD_Draw_Circle(...) {
    // Uses HAL_Delay() for timing
    // Uses HAL_SPI functions for communication
    // Uses HAL_GPIO functions for control signals
}
```

---

## Troubleshooting HAL Issues

| Problem | Likely Cause | Solution |
|---------|--------------|----------|
| `HAL_Delay()` doesn't work | Forgot `HAL_Init()` | Call `HAL_Init()` first |
| Serial output doesn't appear | UART not initialized | Call `MX_USART2_UART_Init()` |
| LED doesn't toggle | Wrong pin name | Check GPIO pin definitions in main.h |
| Code hangs on `HAL_Delay()` | Interrupt conflict | Check if Systick interrupt is enabled |
| GPIO pin stuck on | Hardware issue | Check connections and pin configuration |

---

## Quick Reference Table

| Function | Purpose | Example |
|----------|---------|---------|
| `HAL_Init()` | Initialize HAL | `HAL_Init();` |
| `SystemClock_Config()` | Set system clock to 80 MHz | `SystemClock_Config();` |
| `MX_GPIO_Init()` | Initialize GPIO pins | `MX_GPIO_Init();` |
| `MX_USART2_UART_Init()` | Initialize serial port | `MX_USART2_UART_Init();` |
| `HAL_GPIO_WritePin()` | Set pin HIGH or LOW | `HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);` |
| `HAL_GPIO_ReadPin()` | Read pin state | `if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) { ... }` |
| `HAL_GPIO_TogglePin()` | Toggle pin state | `HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);` |
| `HAL_Delay()` | Wait in milliseconds | `HAL_Delay(500);` |
| `HAL_GetTick()` | Get elapsed milliseconds | `uint32_t ms = HAL_GetTick();` |
| `HAL_UART_Transmit()` | Send serial data | `HAL_UART_Transmit(&huart2, data, len, HAL_MAX_DELAY);` |
| `HAL_ADC_Start()` | Start ADC conversion | `HAL_ADC_Start(&hadc1);` |
| `HAL_ADC_PollForConversion()` | Wait for ADC conversion | `HAL_ADC_PollForConversion(&hadc1, 100);` |
| `HAL_ADC_GetValue()` | Get ADC result | `uint32_t val = HAL_ADC_GetValue(&hadc1);` |
| `HAL_ADC_Stop()` | Stop ADC conversion | `HAL_ADC_Stop(&hadc1);` |
| `HAL_RNG_Init()` | Initialize RNG | `HAL_RNG_Init(&hrng);` |
| `HAL_RNG_GenerateRandomNumber()` | Generate random number | `HAL_RNG_GenerateRandomNumber(&hrng, &rand);` |
| `MX_ADC1_Init()` | Initialize ADC1 | `MX_ADC1_Init();` |
| `MX_RNG_Init()` | Initialize RNG | `MX_RNG_Init();` |

